<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fBm Nebula Test</title>
    <link href="https://fonts.googleapis.com/css2?family=Offside&family=Workbench&display=swap" rel="stylesheet">
    <style>
        html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#050505; font-family:'Offside', sans-serif; }
        canvas { display:block; }
        .note { position:absolute; top:20px; left:20px; color:#e8e8e8; font-family:Offside, sans-serif; }
    </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="note">Canvas fractal brownian motion nebula (deep obsidian + indigo/magenta/teal)</div>
<script>
// Simplex noise implementation (adapted from https://github.com/jwagner/simplex-noise.js)
class SimplexNoise {
    constructor(r) { if (!r) r=Math; this.p=new Uint8Array(256); for (let i=0;i<256;i++) this.p[i]=i; for (let i=255;i>0;i--){let n=Math.floor((i+1)*r.random());let q=this.p[i];this.p[i]=this.p[n];this.p[n]=q;} this.perm=new Uint8Array(512);this.permMod12=new Uint8Array(512); for(let i=0;i<512;i++){this.perm[i]=this.p[i&255];this.permMod12[i]=this.perm[i]%12;} }
    noise2D(x,y){
        const grad3=[ [1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1] ];
        const F2=0.5*(Math.sqrt(3)-1); const G2=(3-Math.sqrt(3))/6;
        let n0=0,n1=0,n2=0;
        let s=(x+y)*F2; let i=Math.floor(x+s); let j=Math.floor(y+s);
        let t=(i+j)*G2; let X=i-t; let Y=j-t; let x0=x-X; let y0=y-Y;
        let i1,j1; if(x0>y0){i1=1; j1=0;} else {i1=0; j1=1;}
        let x1=x0-i1+G2; let y1=y0-j1+G2;
        let x2=x0-1+2*G2; let y2=y0-1+2*G2;
        let ii=i&255; let jj=j&255;
        let gi0=this.permMod12[ii+this.perm[jj]];
        let gi1=this.permMod12[ii+i1+this.perm[jj+j1]];
        let gi2=this.permMod12[ii+1+this.perm[jj+1]];
        let t0=0.5 - x0*x0 - y0*y0;
        if(t0>=0){ t0*=t0; n0=t0*t0*(grad3[gi0][0]*x0 + grad3[gi0][1]*y0); }
        let t1=0.5 - x1*x1 - y1*y1;
        if(t1>=0){ t1*=t1; n1=t1*t1*(grad3[gi1][0]*x1 + grad3[gi1][1]*y1); }
        let t2=0.5 - x2*x2 - y2*y2;
        if(t2>=0){ t2*=t2; n2=t2*t2*(grad3[gi2][0]*x2 + grad3[gi2][1]*y2); }
        return 70*(n0+n1+n2);
    }
}

const noise=new SimplexNoise();
const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
let w,h;
function resize(){w=canvas.width=window.innerWidth; h=canvas.height=window.innerHeight;}
window.addEventListener('resize',resize); resize();

const layers=[
    {scale:0.003, speedX:0.01, speedY:0.008, color:[48,0,96,0.1]},
    {scale:0.005, speedX:-0.008, speedY:0.01, color:[255,0,255,0.08]},
    {scale:0.002, speedX:0.006, speedY:-0.005, color:[0,255,255,0.06]},
    {scale:0.004, speedX:-0.005, speedY:-0.007, color:[96,0,144,0.09]}
];
let time=0;

function draw(){
    ctx.globalCompositeOperation='source-over';
    ctx.fillStyle='#050505'; ctx.fillRect(0,0,w,h);
    layers.forEach(l=>{
        ctx.globalCompositeOperation='screen';
        let img=ctx.createImageData(w,h);
        let data=img.data;
        for(let y=0;y<h;y++){
            for(let x=0;x<w;x++){
                let n=0;
                let nx=x*l.scale+time*l.speedX;
                let ny=y*l.scale+time*l.speedY;
                n = noise.noise2D(nx, ny) * 0.5 + 0.5; // normalize
                let idx=(y*w+x)*4;
                data[idx]=l.color[0];
                data[idx+1]=l.color[1];
                data[idx+2]=l.color[2];
                data[idx+3]=Math.floor(n * 255 * l.color[3]);
            }
        }
        ctx.putImageData(img,0,0);
    });
    time+=0.5;
    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>