<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized Metaball Liquid</title>
    <link href="https://fonts.googleapis.com/css2?family=Offside&family=Workbench&display=swap" rel="stylesheet">
    <style>
        html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#050505; font-family:'Offside', sans-serif; }
        #canvas-container { position:absolute; top:0; left:0; z-index:1; width:100%; height:100%; filter: blur(20px) contrast(1.5); }
        canvas { display:block; width:100%; height:100%; }
        .container { position:relative; z-index:2; text-align:center; color:#e8e8e8; top:50%; transform:translateY(-50%); width:100%; }
        h1 { font-family:'Workbench', serif; font-size:3rem; margin-bottom:1rem; }
        .note { font-size:1.2rem; margin-bottom:2rem; }
        .slider-group { display:inline-block; text-align:left; margin:0 10px; }
        .slider-group label { display:block; font-size:0.9rem; margin-bottom:4px; }
        .slider-group input[type=range] { width:150px; }
    </style>
</head>
<body>
<div id="canvas-container">
    <canvas id="c"></canvas>
</div>
<div class="container">
    <h1>Field-based metaball (optimized)</h1>
    <p class="note">Low-res field + manual color conversion for smooth 60â€¯FPS on desktop.</p>
    <div id="controls"></div>
</div>
<script>
// minimal HSL -> RGB converter
function hslToRgb(h, s, l){
    h=h/360; s=s/100; l=l/100;
    let r,g,b;
    if(s===0){ r=g=b=l; }
    else{
        const hue2rgb=(p, q, t)=>{
            if(t<0) t+=1;
            if(t>1) t-=1;
            if(t<1/6) return p+(q-p)*6*t;
            if(t<1/2) return q;
            if(t<2/3) return p+(q-p)*(2/3 - t)*6;
            return p;
        };
        const q = l<0.5 ? l*(1+s) : l+s-l*s;
        const p = 2*l-q;
        r = hue2rgb(p, q, h+1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h-1/3);
    }
    return [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];
}

const canvas=document.getElementById('c');
const ctx=canvas.getContext('2d');
let w,h;
let w2,h2;
const scale=0.25; // render at 25% resolution (tweakable)

// offscreen buffer for low-res render to avoid drawing canvas->canvas
const buf = document.createElement('canvas');
const bufCtx = buf.getContext('2d');

function resize(){
    w=canvas.width=window.innerWidth;
    h=canvas.height=window.innerHeight;
    w2=Math.max(2, Math.ceil(w*scale));
    h2=Math.max(2, Math.ceil(h*scale));
    buf.width = w2; buf.height = h2;
}
window.addEventListener('resize',resize);
resize();

// particles with explicit RGB color palette (indigo, magenta, teal, amber)
const particles=[
    {x:0.2,y:0.3,vx:0.01,vy:0.005,r:120,color:[75,0,130]},
    {x:0.7,y:0.6,vx:-0.008,vy:0.01,r:150,color:[255,0,200]},
    {x:0.5,y:0.2,vx:0.006,vy:-0.007,r:100,color:[0,200,160]},
    {x:0.3,y:0.8,vx:-0.005,vy:-0.006,r:130,color:[255,140,0]}
];

let threshold=1.0;
let fadeStrength = 0.12; // how quickly previous frames fade (0 = persistent, 1 = immediate)
const controls=document.getElementById('controls');
const thrGroup=document.createElement('div');
thrGroup.className='slider-group';
const thrLabel=document.createElement('label');
thrLabel.textContent='Threshold';
const thrSlider=document.createElement('input');
thrSlider.type='range';thrSlider.min=0;thrSlider.max=6;thrSlider.step=0.01;thrSlider.value=threshold;
thrSlider.addEventListener('input',e=>{threshold=parseFloat(e.target.value);});
thrGroup.appendChild(thrLabel);thrGroup.appendChild(thrSlider);controls.appendChild(thrGroup);

// fade slider
const fadeGroup = document.createElement('div'); fadeGroup.className='slider-group';
const fadeLabel = document.createElement('label'); fadeLabel.textContent='Frame fade (temporal)';
const fadeSlider = document.createElement('input'); fadeSlider.type='range'; fadeSlider.min=0; fadeSlider.max=0.6; fadeSlider.step=0.01; fadeSlider.value=fadeStrength;
fadeSlider.addEventListener('input', e=>{fadeStrength = parseFloat(e.target.value);});
fadeGroup.appendChild(fadeLabel); fadeGroup.appendChild(fadeSlider); controls.appendChild(fadeGroup);

// Gaussian-based influence field; returns per-particle weighted sum info
function fieldContrib(x,y){
    let sum=0;
    let rAcc=0, gAcc=0, bAcc=0;
    particles.forEach(p=>{
        const dx = x - p.x*w;
        const dy = y - p.y*h;
        const d2 = dx*dx + dy*dy + 0.000001;
        // Gaussian falloff; sigma proportional to particle radius
        const sigma = Math.max(20, p.r * 0.5);
        const inv = Math.exp(-d2 / (2 * sigma * sigma)) * (p.r*0.5);
        sum += inv;
        rAcc += inv * p.color[0];
        gAcc += inv * p.color[1];
        bAcc += inv * p.color[2];
    });
    return {sum, rAcc, gAcc, bAcc};
}

function draw(){
    // low-res image buffer
    const img = bufCtx.createImageData(w2,h2);
    const data = img.data;
    for(let j=0;j<h2;j++){
        for(let i=0;i<w2;i++){
            const x = i/scale;
            const y = j/scale;
            const c = fieldContrib(x,y);
            if(c.sum > threshold){
                const idx = (j*w2 + i)*4;
                // normalized color by contribution
                const r = Math.min(255, Math.floor(c.rAcc / c.sum));
                const g = Math.min(255, Math.floor(c.gAcc / c.sum));
                const b = Math.min(255, Math.floor(c.bAcc / c.sum));
                // alpha scales with strength above threshold (soft ramp)
                const alpha = Math.min(255, Math.floor(255 * Math.tanh((c.sum - threshold) * 0.08)));
                data[idx] = r; data[idx+1] = g; data[idx+2] = b; data[idx+3] = alpha;
            }
        }
    }
    bufCtx.putImageData(img, 0, 0);

    // temporal fade: draw a very slight dark rectangle to fade previous main canvas
    ctx.fillStyle = `rgba(5,5,5,${fadeStrength})`;
    ctx.fillRect(0,0,w,h);

    // draw buffer upscaled onto main canvas
    ctx.drawImage(buf, 0, 0, w2, h2, 0, 0, w, h);

    // update particle positions (wrap)
    particles.forEach(p=>{
        p.x += p.vx * 0.6; // slightly slower motion for viscous feel
        p.y += p.vy * 0.6;
        if(p.x<0) p.x+=1; if(p.x>1) p.x-=1;
        if(p.y<0) p.y+=1; if(p.y>1) p.y-=1;
    });
    requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>